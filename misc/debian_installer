#!/bin/bash
set -euo pipefail
set +x

usage() {
  echo 'usage: dev_install [ARGS]

-t, --target <path>   path to target disk device, physical volume, or file

-l, --label           prefix for labeling VGs, LVs, partitions and filesystems
-k, --public-key      path to a public ssh key file to include in image

-e, --encrypt         encrypt home partition
-p, --purge-all       remove all existing partitions from device (default is to
                      create new partitions on existing free disk space)

-b, --boot-size       boot partition size
-r, --root-size       root partition size
-h, --home-size       home partition size (omit if no defined)
-v, --var-size        var partition size (omit if no defined)

--boot-part           existing boot partition path to utilize
--root-part           existing root partition path to utilize
--home-part           existing home partition path to utilize
--var-part            existing var partition path to utilize

--help                this help message

examples:

deb_dev_install -t /dev/sdb -b 512M -r 128G 
deb_dev_install -t /dev/sdb -b 512M -r 64G -u 32G -v 32G -p
deb_dev_install -t /dev/sdb -b 1G -r 64G --boot-part=/dev/sdb1 --root-part=/dev/sdb2'
  exit 0
}

# just a helper function defined early
err_exit() {
  printf 'ERROR: %s\n' "${1}"
  exit 1
}


# initilize global variables
# ==========================

# target - a path to the disk or file
DEV=

# encrypt the home partition
PUB_SSH_FILE=

# encrypt the home partition
ENCRYPT=false

# remove all existing partitions
PURGE=false

# size of partitions and total size
BOOT_SIZE=
ROOT_SIZE=
HOME_SIZE=
VAR_SIZE=
BOOT_SIZE_B=
ROOT_SIZE_B=
HOME_SIZE_B=
VAR_SIZE_B=
SIZE=

# path of existing partitions to use
GRUB_PART=
BOOT_PART=
ROOT_PART=
HOME_PART=
VAR_PART=

# partition numbers
GRUB_PART_N=
BOOT_PART_N=
ROOT_PART_N=
HOME_PART_N=
VAR_PART_N=

# default path to mount partitions
ROOT_DIR=/tmp/deb_build

# type of the disk: 'device' (path to /dev/*) or 'file' (path to a regular file)
DEV_TYPE=

# first free loop device to use for dev_type 'file'
LOOP_DEV=

# prefix for labeling partitions and filesystems
LABEL=

# dev mapper name for encrypted root
MAP_DEV=tmp_debootstrap_home
PART_ENC="/dev/mapper/${MAP_DEV}"

# UUIDs for partitions to be created, either generated by the script or read
# from the sys config files
UUID_GRUB="$(uuidgen | sed 's|.*-.*-.*-.*-.\{4\}|00000000-0000-0000-0000-0000|')"
UUID_BOOT="$(uuidgen | sed 's|.*-.*-.*-.*-.\{4\}|00000000-0000-0000-0000-0000|')"
UUID_ROOT="$(uuidgen | sed 's|.*-.*-.*-.*-.\{4\}|00000000-0000-0000-0000-0000|')"
UUID_HOME="$(uuidgen | sed 's|.*-.*-.*-.*-.\{4\}|00000000-0000-0000-0000-0000|')"
UUID_VAR="$(uuidgen | sed 's|.*-.*-.*-.*-.\{4\}|00000000-0000-0000-0000-0000|')"

# chroot command interpreter
CCMD="chroot ${ROOT_DIR} env -i DEBIAN_FRONTEND=noninteractive TERM=linux PATH=/usr/bin:/usr/sbin"

# parse args
# ==========

opts=t:l:k:epb:r:h:v:

long=target:,label:,public-key:,encrypt,purge-all,
long+=boot-size:,root-size:,home-size:,var-size:,
long+=boot-part:,root-part:,home-part:,var-part,help

parsed_opts=$(getopt -o=${opts} --long=${long} --name "$0" -- "$@")

while [[ ${#} -gt 0 ]]; do
  key="${1}"
  case ${key} in
  -t | --target)
    readonly DEV="${2}"
    shift 2
    ;;
  -l | --label)
    readonly LABEL="${2}"
    shift 2
    ;;
  -k | --public-key)
    readonly PUB_SSH_FILE="${2}"
    shift 2
    ;;
  -e | --encrypt)
    readonly ENCRYPT=true
    shift
    ;;
  -p | --purge-all)
    readonly PURGE=true
    shift
    ;;
  -b | --boot-size)
    BOOT_SIZE_B="$(numfmt --from=iec "${2}")"
    readonly BOOT_SIZE_B
    readonly BOOT_SIZE="${2}"
    shift 2
    ;;
  -r | --root-size)
    ROOT_SIZE_B="$(numfmt --from=iec "${2}")"
    readonly ROOT_SIZE_B
    readonly ROOT_SIZE="${2}"
    shift 2
    ;;
  -h | --home-size)
    HOME_SIZE_B="$(numfmt --from=iec "${2}")"
    readonly HOME_SIZE_B
    readonly HOME_SIZE="${2}"
    shift 2
    ;;
  -v | --var-size)
    VAR_SIZE_B="$(numfmt --from=iec "${2}")"
    readonly VAR_SIZE_B
    readonly VAR_SIZE="${2}"
    shift 2
    ;;
  --boot-part)
    readonly BOOT_PART="${2}"
    shift 2
    ;;
  --root-part)
    readonly ROOT_PART="${2}"
    shift 2
    ;;
  --home-part)
    readonly HOME_PART="${2}"
    shift 2
    ;;
  --var-part)
    readonly VAR_PART="${2}"
    shift 2
    ;;
  --help)
    usage
    ;;
  *)
    err_exit "unknown option '${key}'"
    ;;
  esac
done

if [[ -z "${DEV}" ]]; then
  if [[ -z "${BOOT_PART}" ]] || [[ -z "${ROOT_PART}" ]] ; then
    err_exit 'missing target device or root+boot partition paths'
  fi
else
  if [[ -n "${BOOT_PART}" ]] || [[ -n "${ROOT_PART}" ]] ; then
    err_exit "either target device or root+boot partition paths must be defined"
  fi
fi

if [[ ${DEV} == /dev/* ]]; then
  DEV_TYPE='device'
else
  DEV_TYPE='file'
fi

SIZE="$(( BOOT_SIZE_B + ROOT_SIZE_B + HOME_SIZE_B + VAR_SIZE_B ))"

# make sure that these global vars are readonly from now on
readonly DEV PUB_SSH_FILE ENCRYPT PURGE \
  BOOT_SIZE ROOT_SIZE HOME_SIZE VAR_SIZE SIZE \
  ROOT_DIR DEV_TYPE \
  UUID_GRUB UUID_ROOT UUID_HOME UUID_VAR


# tests and checks
# ================

command -v sgdisk >/dev/null || err_exit 'sgdisk from gdisk missing'
command -v partprobe  >/dev/null || err_exit 'partprobe from parted missing'
command -v mkfs.fat  >/dev/null || err_exit 'mkfs.fat from dosfstools missing'

[[ -z "${BOOT_SIZE}" ]] && err_exit 'boot partition size not defined'
[[ -z "${ROOT_SIZE}" ]] && err_exit 'root partition size not defined'

[[ -z "${LABEL}" ]] && err_exit 'label prefix not defined'

findmnt "${ROOT_DIR}" && err_exit "${ROOT_DIR} already mounted"
[ "${ROOT_DIR}" == '' ] && err_exit "ROOT_DIR is empty"
[ "${ROOT_DIR}" == '/' ] && err_exit "/ as ROOT_DIR not allowed"

if [ ${DEV_TYPE} == 'file' ]; then
  command -v qemu-img >/dev/null || err_exit 'qemu-img from qemu-system-x86 missing'
fi


# functions
# =========

get_free_space() {
  if [ "${DEV_TYPE}" == 'device' ] && [ -n "${DEV}" ]; then
    FREE_SPACE="$(parted "${DEV}" unit B print free \
      | grep 'Free Space' \
      | tail -n1 \
      | awk '{print $3}' \
      | tr -d 'B')"

    if [[ -z "${FREE_SPACE}" ]]; then
      err_exit "target disk probably doesn't have partition table"
    fi

    if [[ "${FREE_SPACE}" -lt "${SIZE}" ]]; then
      err_exit "not enough unpartitioned space"
    fi
  fi

  readonly FREE_SPACE
}

partsync() {
  partprobe "${DEV}"
  sleep 0.3
}

purge_partitions() {
  echo '+ purging existing partitions...'
  sgdisk --zap-all "${DEV}" && partsync
  dd if=/dev/zero of="${DEV}" bs=1M count=128 >/dev/null 2>&1
  sgdisk -g "${DEV}" && partsync
  sleep 0.3
}

get_partitions() {
  if [ "${DEV_TYPE}" == 'device' ]; then
    # find partition numbers to use if partitions are not defined
    if [[ -n "${DEV}" ]]; then
      partsync
      local last_part
      last_part="$(sgdisk -p "${DEV}" \
        | sed -n '/^Number/,$p' \
        | tail -n +2 \
        | sort -n \
        | awk '{print $1}' \
        | tail -n1 \
        2> /dev/null)"

      [[ -z "${last_part}" ]] || [ "${PURGE}" == 'true' ] && last_part=0

      GRUB_PART="${DEV}$((++last_part))"
      GRUB_PART_N="${last_part}"

      BOOT_PART="${DEV}$((++last_part))"
      BOOT_PART_N="${last_part}"

      ROOT_PART="${DEV}$((++last_part))"
      ROOT_PART_N="${last_part}"

      [[ -n "${HOME_SIZE}" ]] && HOME_PART="${DEV}$((++last_part))"
      [[ -n "${HOME_SIZE}" ]] && HOME_PART_N="${last_part}"

      [[ -n "${VAR_SIZE}" ]] && VAR_PART="${DEV}$((++last_part))"
      [[ -n "${VAR_SIZE}" ]] && VAR_PART_N="${last_part}"

      sleep 0.3
    fi

  elif [ "${DEV_TYPE}" == 'file' ]; then
    LOOP_DEV="$(losetup --find)"

    GRUB_PART="${LOOP_DEV}p1"
    GRUB_PART_N=1

    BOOT_PART="${LOOP_DEV}p2"
    BOOT_PART_N=2

    ROOT_PART="${LOOP_DEV}p3"
    ROOT_PART_N=3

    [[ -n "${HOME_SIZE}" ]] && HOME_PART="${LOOP_DEV}p4"
    [[ -n "${HOME_SIZE}" ]] && HOME_PART_N=4

    [[ -n "${VAR_SIZE}" ]] && VAR_PART="${LOOP_DEV}p5"
    [[ -n "${VAR_SIZE}" ]] && VAR_PART_N=5
    sleep 0.3
  fi
}

create_partitions() {
  if [ "${DEV_TYPE}" == 'file' ]; then
    echo '+ preparing vm file...'
    qemu-img create -f raw "${DEV}" "$(( SIZE + 10*1024*1024 ))"
    sgdisk -g "${DEV}" && partsync
  fi

  partsync

  echo '+ creating grub partition...'
  sgdisk --new "${GRUB_PART_N}::+2M" \
    -u "${GRUB_PART_N}:${UUID_GRUB}" "${DEV}" && partsync

  # mark the grub partition as BIOS boot partition
  sgdisk -t "${GRUB_PART_N}:ef02" "${DEV}" && partsync

  # name the grub partition
  sgdisk -c "${GRUB_PART_N}:${LABEL}-grub" "${DEV}" && partsync


  echo '+ creating boot partition...'
  sgdisk --new "${BOOT_PART_N}:+2M:+${BOOT_SIZE}" \
    -u "${BOOT_PART_N}:${UUID_BOOT}" "${DEV}" && partsync

  # for efi: todo add uefi flag
  #sgdisk --new "${BOOT_PART_N}:+2M:+${BOOT_SIZE}" "${DEV}" && partsync

  # name the boot partition
  sgdisk -c "${BOOT_PART_N}:${LABEL}-boot" "${DEV}" && partsync

  # mark the boot partition as EFI system partition (todo: add uefi flag)
  #sgdisk -t "${BOOT_PART_N}:ef00" "${DEV}" && partsync

  # set legacy bios bootable attribute on boot device
  sgdisk --attributes "${BOOT_PART_N}:set:2" "${DEV}" && partsync


  echo '+ creating root partition...'
  sgdisk --new "${ROOT_PART_N}::+${ROOT_SIZE}" \
    -u "${ROOT_PART_N}:${UUID_ROOT}" "${DEV}" && partsync

  # name the root partition
  sgdisk -c "${ROOT_PART_N}:${LABEL}-root" "${DEV}" && partsync

  # mark the root partition as linux filesystem
  sgdisk -t "${ROOT_PART_N}:8300" "${DEV}" && partsync

  if [[ -n "${HOME_SIZE}" ]]; then
    echo '+ creating home partition...'
    sgdisk --new "${HOME_PART_N}::+${HOME_SIZE}" \
      -u "${HOME_PART_N}:${UUID_HOME}" "${DEV}" && partsync
    sgdisk -t "${HOME_PART_N}:8300" "${DEV}" && partsync
    sgdisk -c "${HOME_PART_N}:${LABEL}-home" "${DEV}" && partsync
  fi


  if [[ -n "${VAR_SIZE}" ]]; then
    echo '+ creating var partition...'
    sgdisk --new "${VAR_PART_N}::+${VAR_SIZE}" \
      -u "${VAR_PART_N}:${UUID_VAR}" "${DEV}" && partsync
    sgdisk -t "${VAR_PART_N}:8300" "${DEV}" && partsync
    sgdisk -c "${VAR_PART_N}:${LABEL}-var" "${DEV}" && partsync
  fi

  if [ "${DEV_TYPE}" == 'file' ]; then
    losetup -Pf "${DEV}"
    sleep 0.3
  fi
}

create_filesystems() {
  echo '+ creating boot filesystem...'
  mkfs.ext4 -F -L "${LABEL}-boot" -U "${UUID_BOOT}" "${BOOT_PART}"

  # for uefi; todo: add uefi flag
  #mkfs.fat -n "${LABEL}-boot" -F32 "${BOOT_PART}"

  echo '+ creating root filesystem...'
  mkfs.ext4 -F -L "${LABEL}-root" -U "${UUID_ROOT}" "${ROOT_PART}"

  if [[ -n "${HOME_SIZE}" ]]; then
    echo '+ creating home filesystem...'
    if [ "${ENCRYPT}" == 'false' ]; then
      mkfs.ext4 -F -L "${LABEL}-home" -U "${UUID_HOME}" "${HOME_PART}"
    else
      cryptsetup -v \
        --type luks2 \
        --hash sha512 \
        --cipher aes-xts-plain64 \
        --key-size 512 \
        --pbkdf argon2id \
        --iter-time 5000 \
        --batch-mode \
        --uuid="${UUID_HOME}" \
        luksFormat "${UUID_HOME}"
      echo 'Enter the password again to mount encrypted home...'
      cryptsetup luksOpen --allow-discards "${HOME_PART}" ${MAP_DEV}
      mkfs.ext4 -F -L "${LABEL}-home" -U "${UUID_HOME}" "${PART_ENC}"
    fi
  fi

  if [[ -n "${VAR_SIZE}" ]]; then
    echo '+ creating var filesystem...'
    mkfs.ext4 -F -L "${LABEL}-var" -U "${UUID_VAR}" "${VAR_PART}"
  fi
}

mount_partitions() {
  echo '+ mounting partitions...'
  mkdir -p "${ROOT_DIR}"
  mount -o sync "${ROOT_PART}" "${ROOT_DIR}"
  mkdir -p ${ROOT_DIR}/{boot,home,var}
  mount -o sync "${BOOT_PART}" "${ROOT_DIR}/boot"

  if [[ -n "${HOME_SIZE}" ]]; then
    if [ "${ENCRYPT}" == true ]; then
      mount -o sync "${PART_ENC}" "${ROOT_DIR}/home"
    else
      mount -o sync "${HOME_PART}" "${ROOT_DIR}/home"
    fi
  fi

  if [[ -n "${VAR_SIZE}" ]]; then
    mount -o sync "${VAR_PART}" "${ROOT_DIR}/var"
  fi
}

set_fstab() {
  echo '+ configuring fstab...'
  # todo: add uefi flag
  #local uuid_boot
  #uuid_boot="$(blkid -s UUID -o value ${BOOT_PART})"

  cat > ${ROOT_DIR}/etc/fstab <<EOF
proc    /proc   proc            rw,nosuid,nodev,noexec,hidepid=2,gid=0  0 0
sys     /sys    sysfs           rw,nosuid,nodev,noexec                  0 0
run     /run    tmpfs           rw,nosuid,nodev,mode=0755               0 0
tmp     /tmp    tmpfs           rw,nosuid,nodev,mode=0777,size=80% 0 0

shm     /dev/shm        tmpfs   rw,nosuid,noexec,mode=1777              0 0
devpts  /dev/pts        devpts  rw,nosuid,noexec,mode=0620,gid=5        0 0
lock    /run/lock       tmpfs   rw,nosuid,nodev,noexec,mode=1777        0 0

UUID=${UUID_ROOT}      /       ext4    rw,lazytime,noiversion          0 1
UUID=${UUID_BOOT}      /boot   ext4    rw,sync,noiversion              0 2
EOF
}

set_timezone() {
  echo '+ configuring timezone...'
  ${CCMD} debconf-set-selections <<EOF
tzdata tzdata/Areas select Europe
tzdata tzdata/Zones/Europe select Warsaw
EOF

  ${CCMD} rm -f /etc/localtime /etc/timezone
  ${CCMD} DEBCONF_NONINTERACTIVE_SEEN=true dpkg-reconfigure -f noninteractive tzdata
}

set_network() {
  echo '+ configuring network...'
  cat > ${ROOT_DIR}/etc/network/interfaces <<EOF
auto lo
iface lo inet loopback

auto eth0
allow-hotplug eth0
iface eth0 inet dhcp
  dns-nameservers 9.9.9.9
EOF

  cat > ${ROOT_DIR}/etc/hosts <<EOF
127.0.0.1       localhost local debian
EOF
}

set_apt() {
  echo '+ configuring apt...'
  cat > ${ROOT_DIR}/etc/apt/sources.list <<EOF
deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
deb http://deb.debian.org/debian-security/ bookworm-security main contrib non-free non-free-firmware
deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware
EOF
  ${CCMD} apt-get update
}

set_locale() {
  echo '+ configuring locale...'
  ${CCMD} apt-get install -y locales
  ${CCMD} debconf-set-selections <<EOF
locales locales/locales_to_be_generated multiselect en_US.UTF-8 UTF-8, pl_PL.UTF-8 UTF-8
locales locales/default_environment_locale select en_US.UTF-8
EOF

  ${CCMD} rm -f /etc/default/locale /etc/locale.gen
  ${CCMD} DEBCONF_NONINTERACTIVE_SEEN=true dpkg-reconfigure -f noninteractive locales
}

set_keyboard() {
  echo '+ configuring keyboard...'
  ${CCMD} apt-get install -y keyboard-configuration
  ${CCMD} debconf-set-selections <<EOF
keyboard-configuration keyboard-configuration/layoutcode string pl
keyboard-configuration keyboard-configuration/xkb-keymap string pl
EOF

  ${CCMD} rm -f /etc/default/keyboard
  ${CCMD} DEBCONF_NONINTERACTIVE_SEEN=true dpkg-reconfigure -f noninteractive keyboard-configuration
}

install_bootloader() {
  echo '+ installing grub...'
  local dev
  case "${DEV_TYPE}" in
    device ) dev=${DEV} ;;
    file   ) dev=${LOOP_DEV} ;;
  esac

  ${CCMD} apt-get -y install grub2
  ${CCMD} grub-install --target=i386-pc ${dev} --locales=
  ${CCMD} update-grub

  # todo: add uefi flag
  #${CCMD} apt-get -y install grub-efi-amd64
  #${CCMD} grub-install --efi-directory=/boot/efi --target=x86_64-efi --locales=

}

deploy_ssh_key() {
  [[ -z ${PUB_SSH_FILE} ]] && return

  mkdir -p ${ROOT_DIR}/root/.ssh
  chmod 700 ${ROOT_DIR}/root/.ssh
  cat ${PUB_SSH_FILE} > ${ROOT_DIR}/root/.ssh/authorized_keys
}

unmount() {
  echo '+ unmounting...'
  umount ${ROOT_DIR}/dev/pts/  ${ROOT_DIR}/{boot,dev,proc,sys}/ ${ROOT_DIR}/

  [ "${ENCRYPT}" == 'true' ] && cryptsetup luksClose ${MAP_DEV}
  [ "${DEV_TYPE}" == 'file' ] && losetup -d "${LOOP_DEV}"
}


# confirmation
# ============

get_partitions

# get free space info early if we're not purging
if [ "${PURGE}" == 'false' ]; then
  get_free_space
fi

echo -e "target device/file   ${DEV}
device type          ${DEV_TYPE}

grub partition       ${GRUB_PART}
boot partition       ${BOOT_PART}
root partition       ${ROOT_PART}
home partition       ${HOME_PART}
var partition        ${VAR_PART}

boot size            ${BOOT_SIZE}
root size            ${ROOT_SIZE}
home size            ${HOME_SIZE}
var size             ${VAR_SIZE}

install size         $(numfmt --to=iec-i --suffix=B --format="%.2f" ${SIZE})"

if [ "${DEV_TYPE}" == 'device' ] && [ -n "${DEV}" ]&& [ ${PURGE} == 'false' ]; then
  echo -n "free space           "
  numfmt --to=iec-i --suffix=B --format="%.2f" ${FREE_SPACE}
fi

if [[ "${PURGE}" == 'true' ]]; then
  echo -e "\nWARNING: This ${DEV_TYPE} is going to be wiped:\n${DEV}"
fi

echo -e '\nexisting disk layout:'
if [ -b "${DEV}" ]; then
  lsblk -o NAME,SIZE,FSUSED,TYPE,FSTYPE,MOUNTPOINT "${DEV}" \
    | tail -n +2
fi

printf "\nPress 'Ctrl+c' to abort or 'Enter' to continue..."
read


# main
# =======

if [[ "${PURGE}" == 'true' ]]; then
  purge_partitions
  get_free_space
fi

# make sure that these global vars are readonly from now on
readonly BOOT_PART ROOT_PART HOME_PART VAR_PART LOOP_DEV

if [[ -n "${BOOT_PART}" ]] && [[ -n "${ROOT_PART}" ]]; then
  create_partitions
fi

create_filesystems
mount_partitions

echo '+ installing...'
debootstrap --arch amd64 --include=vim,openssh-server bookworm ${ROOT_DIR} http://ftp.uk.debian.org/debian

mount --bind /dev /${ROOT_DIR}/dev
mount --bind /dev/pts /${ROOT_DIR}/dev/pts
mount --bind /proc /${ROOT_DIR}/proc
mount --bind /sys /${ROOT_DIR}/sys

set_fstab
set_timezone
set_network
set_apt
set_locale
set_keyboard

echo '+ installing kernel...'
${CCMD} apt-get -y --no-install-recommends install linux-image-amd64 zstd

install_bootloader
deploy_ssh_key
unmount

echo '+ done'



# todo: add uefi flag
#echo "don't forget to manually add uefi entries, e.g.:"
#echo 'efibootmgr -v -c -d /dev/sda -p 1 -l \\efi\\boot\\bootx64.efi -L "xx syslinux"'
